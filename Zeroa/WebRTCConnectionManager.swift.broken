import Foundation
import WebRTC
import Combine
import os.log

class WebRTCConnectionManager: NSObject, ObservableObject {
    static let shared = WebRTCConnectionManager()
    
    @Published var isConnected = false
    @Published var activeConnections: [String: RTCPeerConnection] = [:]
    @Published var connectionStatus = "Disconnected"
    
    private var factory: RTCPeerConnectionFactory?
    private var stunServers: [RTCIceServer] = []
    private var turnServers: [RTCIceServer] = []
    private var cancellables = Set<AnyCancellable>()
    
    // STUN/TURN server configuration
    private let stunServerURL = "stun:stun.l.google.com:19302"
    private let turnServerURL = "turn:43.224.35.187:3478"
    private let turnUsername = "zeroa_user"
    private let turnCredential = "zeroa_password"
    
    override init() {
        super.init()
        setupWebRTC()
        setupSTUNServers()
        setupTURNServers()
    }
    
    private func setupWebRTC() {
        RTCInitializeSSL()
        
        factory = RTCPeerConnectionFactory()
        
        logger.info("✅ WebRTC initialized")
    }
    
    private func setupSTUNServers() {
        let stunServer = RTCIceServer(urlStrings: [stunServerURL])
        stunServers.append(stunServer)
        logger.info("✅ STUN servers configured")
    }
    
    private func setupTURNServers() {
        let turnServer = RTCIceServer(
            urlStrings: [turnServerURL],
            username: turnUsername,
            credential: turnCredential
        )
        turnServers.append(turnServer)
        logger.info("✅ TURN servers configured")
    }
    
    // MARK: - Connection Management
    
    func createPeerConnection(for peerID: String) -> RTCPeerConnection? {
        guard let factory = factory else {
            logger.error("❌ WebRTC factory not initialized")
            return nil
        }
        
        let config = RTCConfiguration()
        config.iceServers = stunServers + turnServers
        config.iceCandidatePoolSize = 10
        config.bundlePolicy = .maxBundle
        config.rtcpMuxPolicy = .require
        config.tcpCandidatePolicy = .enabled
        config.continualGatheringPolicy = .gatherContinually
        config.keyType = .ECDSA
        
        let constraints = RTCMediaConstraints(
            mandatoryConstraints: nil,
            optionalConstraints: [
                "DtlsSrtpKeyAgreement": "true"
            ]
        )
        
        let peerConnection = factory.peerConnection(
            with: config,
            constraints: constraints,
            delegate: self
        )
        
        activeConnections[peerID] = peerConnection
        logger.info("✅ Created peer connection for \(peerID)")
        
        return peerConnection
    }
    
    func connectToPeer(peerID: String, offerSDP: String) async throws -> String {
        guard let peerConnection = createPeerConnection(for: peerID) else {
            throw WebRTCError.connectionFailed
        }
        
        // Set remote description (offer)
        let offer = RTCSessionDescription(type: .offer, sdp: offerSDP)
        try await setRemoteDescription(offer, for: peerConnection)
        
        // Create answer
        let answer = try await createAnswer(for: peerConnection)
        try await setLocalDescription(answer, for: peerConnection)
        
        return answer.sdp
    }
    
    func acceptConnection(peerID: String, answerSDP: String) async throws {
        guard let peerConnection = activeConnections[peerID] else {
            throw WebRTCError.connectionNotFound
        }
        
        let answer = RTCSessionDescription(type: .answer, sdp: answerSDP)
        try await setRemoteDescription(answer, for: peerConnection)
        
        logger.info("✅ Accepted connection from \(peerID)")
    }
    
    // MARK: - Data Channel Management
    
    func createDataChannel(for peerID: String, label: String) -> RTCDataChannel? {
        guard let peerConnection = activeConnections[peerID] else {
            logger.error("❌ No peer connection found for \(peerID)")
            return nil
        }
        
        let config = RTCDataChannelConfiguration()
        config.isOrdered = true
        config.maxRetransmits = 3
        
        let dataChannel = peerConnection.dataChannel(
            forLabel: label,
            configuration: config
        )
        
        dataChannel.delegate = self
        logger.info("✅ Created data channel '\(label)' for \(peerID)")
        
        return dataChannel
    }
    
    func sendMessage(_ message: String, to peerID: String, via channel: String) {
        guard let peerConnection = activeConnections[peerID] else {
            logger.error("❌ Cannot send message to \(peerID)")
            return
        }
        
        let config = RTCDataChannelConfiguration()
        let dataChannel = peerConnection.dataChannel(forLabel: channel, configuration: config)
            logger.error("❌ Cannot send message to \(peerID)")
            return
        }
        
        let data = message.data(using: .utf8) ?? Data()
        let buffer = RTCDataBuffer(data: data, isBinary: false)
        
        if dataChannel.sendData(buffer) {
            logger.info("✅ Sent message to \(peerID)")
        } else {
            logger.error("❌ Failed to send message to \(peerID)")
        }
    }
    
    // MARK: - Helper Methods
    
    private func setRemoteDescription(_ description: RTCSessionDescription, for peerConnection: RTCPeerConnection) async throws {
        return try await withCheckedThrowingContinuation { continuation in
            peerConnection.setRemoteDescription(description) { error in
                if let error = error {
                    continuation.resume(throwing: error)
                } else {
                    continuation.resume()
                }
            }
        }
    }
    
    private func setLocalDescription(_ description: RTCSessionDescription, for peerConnection: RTCPeerConnection) async throws {
        return try await withCheckedThrowingContinuation { continuation in
            peerConnection.setLocalDescription(description) { error in
                if let error = error {
                    continuation.resume(throwing: error)
                } else {
                    continuation.resume()
                }
            }
        }
    }
    
    private func createAnswer(for peerConnection: RTCPeerConnection) async throws -> RTCSessionDescription {
        return try await withCheckedThrowingContinuation { continuation in
            let constraints = RTCMediaConstraints(
                mandatoryConstraints: [
                    "OfferToReceiveAudio": "true",
                    "OfferToReceiveVideo": "true"
                ],
                optionalConstraints: nil
            )
            
            peerConnection.answer(for: constraints) { description, error in
                if let error = error {
                    continuation.resume(throwing: error)
                } else if let description = description {
                    continuation.resume(returning: description)
                } else {
                    continuation.resume(throwing: WebRTCError.answerCreationFailed)
                }
            }
        }
    }
    
    // MARK: - Cleanup
    
    func disconnectFromPeer(_ peerID: String) {
        guard let peerConnection = activeConnections[peerID] else { return }
        
        peerConnection.close()
        activeConnections.removeValue(forKey: peerID)
        logger.info("✅ Disconnected from \(peerID)")
    }
    
    func disconnectAll() {
        for (peerID, _) in activeConnections {
            disconnectFromPeer(peerID)
        }
        logger.info("✅ Disconnected from all peers")
    }
    
    deinit {
        disconnectAll()
        RTCCleanupSSL()
    }
}

// MARK: - RTCPeerConnectionDelegate

extension WebRTCConnectionManager: RTCPeerConnectionDelegate {
    func peerConnection(_ peerConnection: RTCPeerConnection, didChange stateChanged: RTCSignalingState) {
        logger.info("📡 Signaling state changed: \(stateChanged.rawValue)")
    }
    
    func peerConnection(_ peerConnection: RTCPeerConnection, didAdd stream: RTCMediaStream) {
        logger.info("📹 Stream added")
    }
    
    func peerConnection(_ peerConnection: RTCPeerConnection, didRemove stream: RTCMediaStream) {
        logger.info("📹 Stream removed")
    }
    
    func peerConnectionShouldNegotiate(_ peerConnection: RTCPeerConnection) {
        logger.info("🔄 Negotiation required")
    }
    
    func peerConnection(_ peerConnection: RTCPeerConnection, didChange newState: RTCIceConnectionState) {
        logger.info("🧊 ICE connection state: \(newState.rawValue)")
        
        DispatchQueue.main.async {
            self.isConnected = newState == .connected
            self.connectionStatus = newState.description
        }
    }
    
    func peerConnection(_ peerConnection: RTCPeerConnection, didChange newState: RTCIceGatheringState) {
        logger.info("🧊 ICE gathering state: \(newState.rawValue)")
    }
    
    func peerConnection(_ peerConnection: RTCPeerConnection, didGenerate candidate: RTCIceCandidate) {
        logger.info("🧊 ICE candidate generated")
        // Send candidate to signaling server
        sendICECandidate(candidate, for: peerConnection)
    }
    
    func peerConnection(_ peerConnection: RTCPeerConnection, didRemove candidates: [RTCIceCandidate]) {
        logger.info("🧊 ICE candidates removed")
    }
    
    func peerConnection(_ peerConnection: RTCPeerConnection, didOpen dataChannel: RTCDataChannel) {
        logger.info("📡 Data channel opened: \(dataChannel.label)")
        dataChannel.delegate = self
    }
    
    private func sendICECandidate(_ candidate: RTCIceCandidate, for peerConnection: RTCPeerConnection) {
        // Find peer ID for this connection
        let peerID = activeConnections.first { $0.value == peerConnection }?.key ?? "unknown"
        
        let candidateData: [String: Any] = [
            "candidate": candidate.sdp,
            "sdpMLineIndex": candidate.sdpMLineIndex,
            "sdpMid": candidate.sdpMid ?? ""
        ]
        
        // Send to signaling server
        // TODO: Implement sendICECandidate in TLSLayer2MessagingService
        logger.info("📡 ICE candidate for \(peerID): \(candidateData)")
    }
}

// MARK: - RTCDataChannelDelegate

extension WebRTCConnectionManager: RTCDataChannelDelegate {
    func dataChannel(_ dataChannel: RTCDataChannel, didReceiveMessageWith buffer: RTCDataBuffer) {
        guard let message = String(data: buffer.data, encoding: .utf8) else {
            logger.error("❌ Failed to decode message")
            return
        }
        
        logger.info("📨 Received message: \(message)")
        
        // Handle incoming message
        DispatchQueue.main.async {
            NotificationCenter.default.post(
                name: .webRTCMessageReceived,
                object: nil,
                userInfo: ["message": message]
            )
        }
    }
    
    func dataChannelDidChangeState(_ dataChannel: RTCDataChannel) {
        logger.info("📡 Data channel state changed: \(dataChannel.readyState.rawValue)")
    }
}

// MARK: - Extensions

extension RTCIceConnectionState {
    var description: String {
        switch self {
        case .new: return "New"
        case .checking: return "Checking"
        case .connected: return "Connected"
        case .completed: return "Completed"
        case .failed: return "Failed"
        case .disconnected: return "Disconnected"
        case .closed: return "Closed"
        case .count: return "Count"
        @unknown default: return "Unknown"
        }
    }
}

enum WebRTCError: Error {
    case connectionFailed
    case connectionNotFound
    case answerCreationFailed
    case invalidSDP
}

// MARK: - Notifications

extension Notification.Name {
    static let webRTCMessageReceived = Notification.Name("webRTCMessageReceived")
}

// MARK: - Logging

private let logger = Logger(subsystem: "com.zeroa.webrtc", category: "ConnectionManager") 